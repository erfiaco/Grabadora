import sounddevice as sd
import soundfile as sf
import numpy as np
import scipy.io.wavfile as wav
import datetime
import time
import os
import signal
from gpiozero import Button
from threading import Event, Thread
import LCD_I2C_classe as LCD
lcd = LCD.LCD_I2C()

# ===== CONFIGURACION =====
sample_rate = 44100
channels = 2
mute = False
grabando = False
reproduciendo = False
ultimo_archivo = None
buffer = []
LOOPS_DIR = "loops"
exit_event = Event()

# Crear carpeta loops si no existe
if not os.path.exists(LOOPS_DIR):
    os.makedirs(LOOPS_DIR)

# ===== BOTONES =====
btn_grabar = Button(26)   # Iniciar/detener grabacion
btn_mute = Button(6)      # Silenciar/desmutear
btn_play = Button(13)     # Reproducir en bucle (siempre)
btn_stop = Button(19)     # Detener reproducción/Salir (3 segundos)

# ===== FUNCIONES =====
def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

def mostrar_estado():
    clear_screen()
    print("=== LOOPER RASPBERRY ===")
    print(f"Mute: {'ON' if mute else 'OFF'}")
    print(f"Estado: {'Grabando' if grabando else 'Reproduciendo' if reproduciendo else 'En espera'}")
    if ultimo_archivo:
        print(f"Último loop: {os.path.basename(ultimo_archivo)}")
    print("Esperando acción...")
    print("Mantén STOP 3 segundos para salir")
    lcd.write(f"Estado: {'Grabando' if grabando else 'Reproduciendo' if reproduciendo else 'En espera'}",1)
    lcd.write(f"Mute: {'ON' if mute else 'OFF'}",2)


def callback_grabacion(indata, frames, time_info, status):
    global mute
    if status:
        print(status)
    if mute:
        indata = np.zeros_like(indata)
    if grabando and not exit_event.is_set():
        buffer.append(indata.copy())

def reproducir_en_bucle():
    global reproduciendo
    if not ultimo_archivo or not os.path.exists(ultimo_archivo):
        print(f"\nNo hay archivo para reproducir. ultimo_archivo: {ultimo_archivo}")
        return
    
    print(f"\nReproduciendo {os.path.basename(ultimo_archivo)} en bucle infinito...")
    data, fs = sf.read(ultimo_archivo, dtype='float32')
    
    reproduciendo = True
    loop_count = 0
    
    while reproduciendo and not exit_event.is_set():
                
        # Iniciar reproducción
        sd.play(data, fs, device='pulse')
        
        # ESPERA ACTIVA - Reemplaza sd.wait() para evitar bloqueo
        # duration = len(data) / fs  # Duración en segundos
        # start_time = time.time()
        #sd.wait sustituye a start ti,e.... etc
        sd.wait()
        
        # Verificar periódicamente si debemos detenernos
        #while (time.time() - start_time < duration and 
        #       reproduciendo and not exit_event.is_set()):
        #    time.sleep(0.01)  # Pequeña pausa de 10ms para ser responsivo
        
        # Limpiar por si acaso
        if not reproduciendo or exit_event.is_set():
            sd.stop()
    
    print("Reproducción terminada")
    reproduciendo = False

def guardar_grabacion():
    global buffer, ultimo_archivo
    if buffer:
        audio = np.concatenate(buffer)
        nombre_archivo = os.path.join(LOOPS_DIR, f"loop_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.wav")
        wav.write(nombre_archivo, sample_rate, audio)
        ultimo_archivo = nombre_archivo
        print(f"\nLoop guardado: {os.path.basename(nombre_archivo)}")
        buffer = []
        return nombre_archivo
    return None

# ===== MANEJO DE SALIDA =====
def monitorear_salida():
    while not exit_event.is_set():
        if btn_stop.is_pressed:
            tiempo_inicio = time.time()
            while btn_stop.is_pressed and not exit_event.is_set():
                if time.time() - tiempo_inicio >= 3:
                    print("\nSolicitud de salida detectada...")
                    exit_event.set()
                    return
                time.sleep(0.1)
        time.sleep(0.1)

def handler_senal(signum, frame):
    print("\nSal de interrupción)
    exit_event.set()

# ===== ACCIONES DE BOTONES =====
def iniciar_detener_grabacion():
    global grabando, buffer, reproduciendo
    if reproduciendo:
        detener_reproduccion()
    
    if not exit_event.is_set():
        if not grabando:
            buffer = []
            grabando = True
            print("\nIniciando grabaci")
        else:
            print("heeey")
            #grabando = False
            #print("\nDeteniendo grabaci")
            #guardar_grabacion()
        mostrar_estado()

def alternar_mute():
    global mute
    mute = not mute
    lcd.write("Mute ON" if mute else "Mute OFF",2)

def manejar_play():
    global grabando, reproduciendo
    if grabando:
        # Si estbando, detener grabaci comenzar bucle
        grabando = False
        archivo = guardar_grabacion()
        if archivo:
            print("\nGrabacdetenida, iniciando reproduccbucle...")
            reproduciendo = True
            Thread(target=reproducir_en_bucle, daemon=False).start()
    elif ultimo_archivo:
        if reproduciendo:
            # Si ya estreproduciendo, detener
            detener_reproduccion()
        else:
            # Si no estreproduciendo, iniciar bucle
            print("\nIniciando reproducen bucle...")
            reproduciendo = True
            Thread(target=reproducir_en_bucle, daemon=False).start()
    else:
        print("\nNo hay grabac para reproducir")
    mostrar_estado()

def detener_reproduccion():
    global reproduciendo, grabando
    if reproduciendo:
        reproduciendo = False
        #sd.stop()
        print("\nReproducción detenida")
    elif grabando:
        grabando = False
        print("\nGrabación detenida por STOP")
        guardar_grabacion()
    mostrar_estado()

# Configurar manejadores de sles
signal.signal(signal.SIGINT, handler_senal)
signal.signal(signal.SIGTERM, handler_senal)

# Asignar funciones a botones
btn_grabar.when_pressed = iniciar_detener_grabacion
btn_mute.when_pressed = alternar_mute
btn_play.when_pressed = manejar_play
btn_stop.when_pressed = detener_reproduccion

# ===== PROGRAMA PRINCIPAL =====
mostrar_estado()

# Iniciar hilos
Thread(target=monitorear_salida, daemon=False).start()

try:
    with sd.InputStream(samplerate=sample_rate, channels=channels, 
                       callback=callback_grabacion, blocksize=1024):
        while not exit_event.is_set():
            time.sleep(0.1)
                
except Exception as e:
    print(f"Error: {str(e)}")
finally:
    print("\nLimpiando recursos...")
    lcd.clear()
    grabando = False
    reproduciendo = False
    sd.stop()
    if buffer:
        guardar_grabacion()
    print("Programa terminado correctamente")
    os._exit(0)
